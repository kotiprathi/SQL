use sql_database;

select * from sales_data;

DELIMITER $$
CREATE FUNCTION add_To_col(a INT)
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE b INT;
    SET b = a + 10;
    RETURN b;
END $$;

SELECT * FROM SALES_DATA;
SELECT MAX(SALES) FROM SALES_DATA;

-- WE CAN USE THE FUNCTION THAT IS DEFINED JUST LIKE BUILT-IN FUNCTION MAX,SUM,AVG,ECT..
SELECT ADD_TO_COL(5);
---------
SELECT QUANTITY + 10 FROM SALES_DATA;
-- insted of manually adding 10 to quantity, we can create a new function based on our requirement and use it anywhere
SELECT quantity,ADD_TO_COL(QUANTITY) AS QUALITY_NEW FROM SALES_DATA;

-- creating function using discount and profit column
DELIMITER &&
CREATE FUNCTION FINAL_PROFIT(PROFIT INT, DISCOUNT INT)
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE FINAL_PROFIT INT;
    SET FINAL_PROFIT = PROFIT - DISCOUNT;
    RETURN FINAL_PROFIT;
END &&;

SELECT PROFIT,DISCOUNT,FINAL_PROFIT(PROFIT,DISCOUNT) FROM SALES_DATA;

-- creating function using discount, profit and sales column
DELIMITER &&
CREATE FUNCTION FINAL_PROFIT_REAL(PROFIT DECIMAL(10,5), DISCOUNT DECIMAL(10,5), SALES DECIMAL(10,5))
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE FINAL_PROFIT_SALE INT;
    SET FINAL_PROFIT_SALE = PROFIT - SALES*DISCOUNT;
    RETURN FINAL_PROFIT_SALE;
END &&;

SELECT PROFIT, DISCOUNT, SALES, FINAL_PROFIT_REAL(PROFIT,DISCOUNT,SALES) FROM SALES_DATA;

-- FUNCTION TO CONVERT INTEGER TO A STRING

DELIMITER $$
CREATE FUNCTION INT_TO_STR(a INT)
RETURNS VARCHAR(10)
DETERMINISTIC
BEGIN
	DECLARE b varchar(10);
    SET b = a;
    RETURN b;
END $$;

SELECT INT_TO_STR(10);
SELECT INT_TO_STR(QUANTITY) AS QUNTITY_TYPE FROM SALES_DATA;
# DROP FUNCTION DATA_OF_DATE; 

SELECT MAX(SALES),MIN(SALES) FROM SALES_DATA;

SELECT DISTINCT * FROM SALES_DATA;

-- CREATING FUNCTION BASED SALES PRICE AND ADDING THE RESULT TO NEW COLUMN INSIDE THE TABLE
DELIMITER &&
CREATE FUNCTION MARK_SALES(SALES INT)
RETURNS VARCHAR(30)
DETERMINISTIC
BEGIN
	DECLARE FLAG_SALES VARCHAR(30);
    IF SALES <= 100 THEN
		SET FLAG_SALES = "SUPER AFFORDABLE PRODUCT";
	ELSEIF SALES > 100 AND SALES <= 300 THEN
		SET FLAG_SALES = "AFFORDABLE PRODUCT";
	ELSEIF SALES > 300 AND SALES <= 600 THEN
		SET FLAG_SALES = "MODERATE PRICE";
	ELSE
		SET FLAG_SALES = "EXPENSIVE PRODUCT";
	END IF;
    RETURN FLAG_SALES;
END &&;
#DROP FUNCTION MARK_SALES;
SELECT MARK_SALES(100);
	
SELECT SALES,MARK_SALES(SALES) FROM SALES_DATA;

ALTER TABLE SALES_DATA
ADD COLUMN MARK_SALES VARCHAR(30);

UPDATE SALES_DATA
SET MARK_SALES = MARK_SALES(SALES);

SELECT * FROM SALES_DATA;

-- LOOPS
CREATE TABLE LOOP_TABLE(VAL INT);

DELIMITER &&
CREATE PROCEDURE INSERT_DATA()
BEGIN
	set @var = 10;
	generate_data : loop
		INSERT INTO LOOP_TABLE VALUES(@VAR);
		set @var = @var + 1;
		if @var = 100 then
			leave generate_data;
		end if;
	end loop generate_data;
END &&;

SELECT * FROM LOOP_TABLE;
CALL INSERT_DATA();

CREATE TABLE LOOP_TABLEOF_3(MULTIPLE_3 INT);

DELIMITER &&
CREATE PROCEDURE INSERT_DATAof_3()
BEGIN
	set @var = 10;
	generate_data : loop
    set @var = @var+1;
    if @var%3 = 0 then
        INSERT INTO LOOP_TABLEOF_3 VALUES(@VAR);
	elseif @var = 100 then
		leave generate_data;
	end if;
end loop generate_data;
END &&;

#DROP PROCEDURE INSERT_DATA4OF_3;
call insert_dataof_3();
select * from loop_tableOF_3;

-- TASK --
/*
1 . Create a loop for a table to insert a record into a taBle for two columns in first coumn you have to 
inset a data ranging from 1 to 100 and in second column you hvae to inset a square of the first column
*/
CREATE TABLE SQUARE_TABLE(COL1 INT,COL2 INT);

DELIMITER &&
CREATE PROCEDURE INSERT_SQUARE_VAL()
BEGIN
	SET @VAR = 1;
	GENERATE_DATA : LOOP
		INSERT INTO SQUARE_TABLE VALUES(@VAR, @VAR*@VAR);
        SET @VAR = @VAR +1;
		IF @VAR = 20 THEN
			LEAVE GENERATE_DATA;
		END IF;
	END LOOP GENERATE_DATA;
END &&;

SELECT * FROM SQUARE_TABLE;
CALL INSERT_SQUARE_VAL();

--  2. create a user defined function to find out a date differences in number of days 
--  MY EXAMPLE: FIND DATE DIFF BTW ORDER_DATE_NEW AND SHIP_DATE_NEW

SELECT * FROM SALES_DATA;
DELIMITER &&
CREATE FUNCTION DATE_DIFFERENCE(DATE1 DATE, DATE2 DATE)
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE DAY_DIFFERENCE INT;
    SET DAY_DIFFERENCE = DATE2 - DATE1;
    RETURN DAY_DIFFERENCE;
END &&;

SELECT ORDER_DATE_NEW, SHIP_DATE_NEW, DATE_DIFFERENCE(ORDER_DATE_NEW,SHIP_DATE_NEW) FROM SALES_DATA;

-- 3 . create a UDF to find out a log base 10 of any given number    
DELIMITER &&
CREATE FUNCTION LOG_BASE10(VAL INT)
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE LOG_BASE_OF10 INT;
    SET LOG_BASE_OF10 (VAL) = 10^X = VAL;
    RETURN X;
END &&;
SELECT LOG_BASE10(100);
DROP FUNCTION LOG_BASE10;

-- 4 . create a UDF which will be able to check a total number of records avaible in your table 
DELIMITER &&
CREATE FUNCTION COUNT_OF_RECORDS(@TABLENAME VARCHAR(30))
RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE L INT;
    SET L = (SELECT COUNT(*) FROM @TABLENAME);
    return L;
END &&;
bank_details
SELECT COUNT_OF_RECORDS();
SELECT COUNT(*) FROM SALES_DATA;

-- 5 . create a procedure to find out  5th highest profit in your sales table you dont have to use rank and windowing function 
DELIMITER &&
CREATE PROCEDURE FIND_5TH_HIGHEST()
BEGIN
	SELECT PROFIT FROM SALES_DATA ORDER BY PROFIT DESC
	LIMIT 1 OFFSET 5;
END &&

CALL FIND_5TH_HIGHEST();
-------------

